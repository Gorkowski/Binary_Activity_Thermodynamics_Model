function [y1] = inverted_NNMcGlashan_singlephase_only_KGv4(x1)
%NN_SINGLEPHASE_LAYERS20 neural network simulation function.
%
% Auto-generated by MATLAB, 25-Oct-2018 16:11:17.
% 
% [y1] = NN_singlephase_layers20(x1) takes these arguments:
%   x = 3xQ matrix, input #1
% and returns:
%   y = 1xQ matrix, output #1
% where Q is the number of samples.

%#ok<*RPMT0>

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [0.342833613099111;0.0257610240123538;0];
x1_step1.gain = [0.927292155075561;9.33917235358487;2];
x1_step1.ymin = -1;

% Layer 1
b1 = [2.8115513858563327965;-2.8139833920503765086;-4.3302743227497852985;-4.349751837066681226;-0.63981997582703342697;4.7675005503601388668;0.45279645177050109606;-1.0345404291116993001;1.0161823552713502572;1.0356383912719269169;-0.87747183735000700011;0.2943761979705025178;-2.070560936922266837;-0.060213766116399454476;3.1521249016629155904;1.3195556335910030299;-15.745441345791590493;1.4102012671955777012;15.471429603096330752;-8.8477924475405682614];
IW1_1 = [0.57110726584119098082 1.1306496699926078531 -0.74401843914779031142;-0.82889657913405689893 -1.1694612356519700214 0.68499205586765321563;-0.12534107788655471372 -2.5395837113293042719 -3.2236295497916733765;-0.13861307468145014909 -2.415374357739061395 -3.2971931413601245353;0.31561472098613213566 -0.15745649609735482 -0.81251717072431084432;-0.093558161586948559996 0.03182870385234023991 3.576342506101297225;0.36491050202880503939 -0.39715585357119276289 -1.3477411772290353031;-1.0406339396414756582 -0.21407388161623372436 -0.95122786995191077608;1.5880956921121385239 0.062716340767363307207 0.76810749308597403573;1.3679870481852720587 0.091800177123299395165 0.80654875517171875643;-1.722020059966734129 -0.48285916904868247945 -1.1460077144677045524;0.58565826801031373172 0.037125978873745225928 -0.30427034161195926076;-0.3244755835663888921 0.50782730241415319217 1.9120399640862708601;0.1690260696595566603 -0.11443126630566542723 -0.38598881921068189937;0.87881127555788085548 0.46622341193841654317 2.0734956433919244922;0.24663732833706358827 0.71392802027574231438 0.77947685255400844806;-13.068060527775543278 0.65108238532587281444 2.8096041952053307789;0.3354860304954600525 0.46336911011163212093 0.8598128687779373891;12.595232466546445238 -0.6501609436283030119 -2.9886688089987853978;-9.7121805651303318996 0.4122374984230980921 -0.37218964168308638074];

% Layer 2
b2 = 3.6579704993857551365;
LW2_1 = [-2.6458202404157664667 -1.8136152137116485772 -2.9739664253461328691 3.3107481889287448951 4.2368752039165711309 -1.3888912259872967514 1.4042883836496007355 -7.3070432829172000666 6.1224762379917203603 -11.965132154178924395 0.3279827844760345168 1.133009694282034685 -1.1720357771598783891 -10.334449723156412304 3.0314366288803320515 4.8232352880932847228 7.2768417094207054063 -11.179570445842548665 7.612807261725062169 0.066253180974265343806];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = 2;
y1_step1.xoffset = 0;

% ===== SIMULATION ========

% Dimensions
Q = size(x1,2); % samples

% Input 1
xp1 = mapminmax_apply(x1,x1_step1);

% Layer 1
a1 = tansig_apply(repmat(b1,1,Q) + IW1_1*xp1);

% Layer 2
a2 = repmat(b2,1,Q) + LW2_1*a1;

% Output 1
y1 = mapminmax_reverse(a2,y1_step1);
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
  y = bsxfun(@minus,x,settings.xoffset);
  y = bsxfun(@times,y,settings.gain);
  y = bsxfun(@plus,y,settings.ymin);
  
  % replace bsxfun, element wise operation, below is method to use in
  % Fortran, that doesn't utilize the matlab bsxfun
%   size_setting = size(x);
%   b = x - repmat(settings.xoffset, size(settings.gain,1)/ size_setting(1,1), size_setting(1,2)); % use 'spread' in fortran https://software.intel.com/en-us/fortran-compiler-developer-guide-and-reference-spread
%   b = b .* repmat(settings.gain, size(settings.gain,1)/ size_setting(1,1), size_setting(1,2));
%   b = b + repmat(settings.ymin, size(settings.gain,1)/ size_setting(1,1), size_setting(1,2));
% 
%   disp(y-b)
%    y=b;
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
  a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
  x = bsxfun(@minus,y,settings.ymin);
  x = bsxfun(@rdivide,x,settings.gain);
  x = bsxfun(@plus,x,settings.xoffset);
  
%   % operations changed
%   size_setting = size(x);
%   b = y - repmat(settings.ymin, size(settings.gain,1)/ size_setting(1,1), size_setting(1,2));
%   b = b ./ repmat(settings.gain, size(settings.gain,1)/ size_setting(1,1), size_setting(1,2));
%   b = b + repmat(settings.xoffset, size(settings.gain,1)/ size_setting(1,1), size_setting(1,2)); % use 'spread' in fortran https://software.intel.com/en-us/fortran-compiler-developer-guide-and-reference-spread
% 
%   disp(x-b)
% %   x=b;
end
